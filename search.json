[{"title":"如何利用hexo发表文章","url":"/2017/08/19/如何利用hexo发表文章/","content":"** 如何利用hexo发表文章 ** <Excerpt in index | 首页摘要>\n    本文修改自[Hexo](https://hexo.io/)自动创建的Hello-World.md，Hexo代码开源。详见[GitHub](https://github.com/hexojs/hexo/)\n<!-- more -->\n<The rest of contents | 余下全文>\n\n本文修改自[Hexo](https://hexo.io/)自动创建的Hello-World.md，Hexo代码开源。详见[GitHub](https://github.com/hexojs/hexo/)。\n\n## 新建文章并发表\n\n## 新建文章\n\n``` bash\n$ hexo new \"新文章\"\n```\n\n## 写文章\n详见：Hexo[官方文档](https://hexo.io/docs/writing.html)\n\n## 生成静态文件\n\n``` bash\n$ hexo generate\n```\n\n详见：Hexo[官方文档](https://hexo.io/docs/generating.html)\n\n## 启动hexo服务\n\n``` bash\n$ hexo server\n```\n\n详见：Hexo[官方文档](https://hexo.io/docs/server.html)\n\n## 部署到远程\n\n``` bash\n$ hexo deploy\n```\n\nHexo[官方文档](https://hexo.io/docs/deployment.html)\n","tags":["Hexo"],"categories":["web"]},{"title":"GMap.net for WPF 使用心得","url":"/2017/08/19/GMap.net-for-WPF-使用心得/","content":"** GMap.net for WPF ** <Excerpt in index | 首页摘要>\n    利用GMap.net for WPF绘制点线面的方式以及未指定长宽的要素与其他要素间相对定位的方式\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## GMap.net概述\n[GMap.net](https://greatmaps.codeplex.com/ \"进入GMap.NET的项目地址\")是一个强大、免费、跨平台、开源的.NET控件，它在WinForm和WPF环境中能够通过Google, Yahoo!, Bing, OpenStreetMap, ArcGIS, Pergo, SigPac等实现寻找路径、地理编码以及地图展示功能，并支持缓存和运行在Mobile环境中。<br>GMap.NET是一个开源的GEO地图定位和跟踪程序。就像谷歌地图、雅虎地图一样，可以自动计算两地的距离，定位经纬度，与Google地图不同的是，该项目是建立在WinForm框架或WPF框架基础上的。可以对地图放大缩小，进行城市标记等。\n  <br>\n## GMap.net for WPF 绘制要素\n因为现在正在利用GMap.net for WPF写一个项目，所以我对WPF版本更加熟悉，如有错误或不当之处，还望指出，共同进步！\n\n* 不同于Winform版本，WPF版本没有图层的概念，但用于显示要素的对象GMapMarker提供了Zindex属性，该属性值大的会遮盖属性值小的。所以大家可以利用Zindex对地理要素建立逻辑上的图层关联。\n \n* WinForm版本绘图可以直接在显示对象上设置图形的属性，如：\n    ```C#\n    GMapPolygon polygon = new GMapPolygon(pointList, \"Polygon\");\n    {\n        polygon.IsHitTestVisible = true;\n        polygon.Fill = new SolidBrush(Color.FromArgb(50, Color.Red));\n        polygon.Stroke = new Pen(Color.Blue, 2);\n    }\n    overlay.Polygons.Add(polygon);\n    ```\n    对于wpf版本的点对象，可以直接指定显示用户控件，如：<br>\n    ```C#\n    GMapMarker marker = new GMapMarker(pointLatLng);\n    {\n        MyUserControl myUserControl = new MyUserControl()\n        marker.Shape = myUserControl;\n        marker.ZIndex = (int)LayerIndex.Point;\n        marker.Offset = new Point(-myUserControl.ActualWidth / 2, -myUserControl.ActualHeight / 2);\n    }\n    mapControl.Markers.Add(marker);\n    ```\n    其中MyUserControl可以重载自UserControl，并自定义显示内容。LayerIndex为自定义的枚举类型。mapControl重载自GMapControl。\n    但是wpf版本的线的属性设置需要重载GMapControl的CreateRoutePath方法，面的属性设置需要重载CreatePolygonPath方法。为了不影响原函数的内容，我们可以参考GMapControl的源代码[*GMapControl.cs*](https://greatmaps.codeplex.com/SourceControl/latest#GMap.NET.WindowsPresentation/GMap.NET.WindowsPresentation/GMapControl.cs \"查看源码文件\")文件。重载CreateRoutePath方法和CreatePolygonPath后的内容如下，只做了少量修改：\n    ```C#\n    /// <summary>\n    /// creates path from list of points, for performance set addBlurEffect to false\n    /// </summary>\n    /// <param name=\"pl\"></param>\n    /// <returns></returns>\n    public override Path CreateRoutePath(List<Point> localPath, bool addBlurEffect)\n    {\n        // Create a StreamGeometry to use to specify myPath.\n        StreamGeometry geometry = new StreamGeometry();\n        \n        using (StreamGeometryContext ctx = geometry.Open())\n        {\n            ctx.BeginFigure(localPath[0], false, false);\n            \n            // Draw a line to the next specified point.\n            ctx.PolyLineTo(localPath, true, true);\n        }\n        \n        // Freeze the geometry (make it unmodifiable)\n        // for additional performance benefits.\n        geometry.Freeze();\n        \n        // Create a path to draw a geometry with.\n        Path myPath = new Path();\n        {\n            // Specify the shape of the Path using the StreamGeometry.\n            myPath.Data = geometry;\n            \n            if (addBlurEffect)\n            {\n                BlurEffect ef = new BlurEffect();\n                {\n                    ef.KernelType = KernelType.Gaussian;\n                    ef.Radius = 0.0;\n                    ef.RenderingBias = RenderingBias.Performance;\n                }\n                \n                myPath.Effect = ef;\n            }\n\n            myPath.Stroke = lineBrush;\n            myPath.StrokeThickness = lineWidth;\n            myPath.StrokeLineJoin = PenLineJoin.Round;\n            myPath.StrokeStartLineCap = PenLineCap.Triangle;\n            myPath.StrokeEndLineCap = PenLineCap.Round;\n            \n            myPath.Opacity = lineOpacity;\n            myPath.IsHitTestVisible = false;\n        }\n        return myPath;\n    }\n    ```\n    `注意:`代码中lineBrush、lineWidth、lineOpacity为重载GMapControl时新添的公共字段。\n     \n     ```C#\n    /// <summary>\n    /// creates path from list of points, for performance set addBlurEffect to false\n    /// </summary>\n    /// <param name=\"pl\"></param>\n    /// <returns></returns>\n    public override Path CreatePolygonPath(List<Point> localPath, bool addBlurEffect)\n    {\n        // Create a StreamGeometry to use to specify myPath.\n        StreamGeometry geometry = new StreamGeometry();\n\n        using (StreamGeometryContext ctx = geometry.Open())\n        {\n            ctx.BeginFigure(localPath[0], true, true);\n\n            // Draw a line to the next specified point.\n            ctx.PolyLineTo(localPath, true, true);\n        }\n\n        // Freeze the geometry (make it unmodifiable)\n        // for additional performance benefits.\n        geometry.Freeze();\n\n        // Create a path to draw a geometry with.\n        Path myPath = new Path();\n        {\n            // Specify the shape of the Path using the StreamGeometry.\n            myPath.Data = geometry;\n\n            if (addBlurEffect)\n            {\n                BlurEffect ef = new BlurEffect();\n                {\n                    ef.KernelType = KernelType.Gaussian;\n                    ef.Radius = 0.0;\n                    ef.RenderingBias = RenderingBias.Performance;\n                }\n\n                myPath.Effect = ef;\n            }\n\n            myPath.Stroke = polygonStrokeBrush;\n            myPath.StrokeThickness = polygonThickness;\n            myPath.StrokeLineJoin = PenLineJoin.Miter;\n            myPath.StrokeStartLineCap = PenLineCap.Triangle;\n            myPath.StrokeEndLineCap = PenLineCap.Square;\n\n            myPath.Fill = polygonFillBush;\n\n            myPath.Opacity = polygonOpacity;\n            myPath.IsHitTestVisible = false;\n        }\n        return myPath;\n    }\n    ```\n    `注意:`代码中polygonStrokeBrush、polygonThickness、polygonFillBush、polygonOpacity为重载GMapControl时新添的公共字段。\n* wpf版本只能绘制Point、PolyLine、Polygon三种图形，绘制圆则需要借助多边形的绘制。示例如下：\n    ```C#\n    public void DrawCircle(PointLatLng center, double R)\n    {\n        double cartesianCenterX = double.MaxValue;\n        double cartesianCenterY = double.MaxValue;\n        double cartesianCenterZ = double.MaxValue;\n\n        mapControl.MapProvider.Projection.FromGeodeticToCartesian(center.Lat, center.Lng, 0, out cartesianCenterX, out cartesianCenterY, out cartesianCenterZ);//将圆心投影到笛卡尔坐标系\n\n        int pointCount = 200;//用于拟合圆的多边形顶点个数\n\n        List<PointLatLng> polygonPointList = new List<PointLatLng>(pointCount);//用于存放多边形顶点\n\n        double interval = 2 * Math.PI / pointCount;\n        for (double degree = 0; degree < 2 * Math.PI; degree += interval)\n        {\n            double tempX = cartesianCenterX + R * Math.Cos(degree);\n            double tempY = cartesianCenterY + R * Math.Sin(degree);\n            double tempLng = double.MaxValue;\n            double tempLat = double.MaxValue;\n            mapControl.MapProvider.Projection.FromCartesianTGeodetic(tempX, tempY, cartesianCenterZ, out tempLat, out tempLng);//投影到WGS84坐标系\n            polygonPointList.Add(new PointLatLng(tempLat, tempLng));\n        }\n\n        GMapPolygon circle = new GMapPolygon(polygonPointList);\n        {\n            circle.ZIndex = (int)LayerIndex.Polygon;\n        }\n        mapControl.Markers.Add(circle);//添加到地图\n    }\n    ```\n    效果如下：\n    ![查看图片](/ref-image/GMap-Wpf-Draw-Circle.png)<br>\n    因为投影问题，说好的圆变为了椭圆，如果想生成正圆，可以在程序中使用一些WebAPI服务替换GMap的投影服务，我们项目使用的是搭建在自己服务器上的的GeoServer服务。效果如下：\n    ![查看图片](/ref-image/FGIS-Damage-Circle.png)<br>\n    `备注：`两张图片截图自不同的程序。\n <br>\n## 未指定长宽的要素与其他要素间相对定位的方式\n在使用GMap添加要素的时候，遇到需要对要素添加Tooltip，但不能指定Tooltip的长宽，且该要素与Tooltip需要水平中心对其，试过很多办法都不能成功，因为wpf控件的ActualWidth和ActualHeight属性必须加载过一次才能有正确的属性值，也就是说如果根据长宽计算GMapMarker的偏移量，Tolltip在第一次显示的时候无法正确定位，经过探索，最终利用wpf控件的SizeChanged响应函数实现了该效果，如果您有其他方法实现，希望能在评论中指出，共同进步。效果如下：<br>\n![查看图片](/ref-image/GMap-Tooltip.png)<br>\n```C#\npublic void AddIconWithTooltip(PointLatLng pll, Uri iconUri, string tooltip)\n{\n    Guid id = Guid.NewGuid();\n    \n    //添加tooltip显示窗口\n    GMapMarker tooltipViewer = new GMapMarker(pll);\n    {\n        tooltipViewer.ZIndex = (int)LayerIndex.Point;\n        tooltipViewer.Tag = id;\n        TooltipForMap content = new TooltipForMap(tooltip, tooltipViewer);\n        tooltipViewer.Shape = content;\n        tooltipViewer.Shape.Visibility = Visibility.Hidden;\n    }\n    mapControl.Markers.Add(tooltipViewer);\n    \n    UIElement shape = new MyIcon(new BitmapImage(iconUri), tooltipViewer);//构造函数：MyIcon(ImageSource image, GMapMarker iconTooltipViewer, double width = 22, double height = 22, bool showTipAlways = false)\n    \n    GMapMarker iconMarker = new GMapMarker(pll);\n    {\n        iconMarker.ZIndex = (int)layerIndex;\n        iconMarker.Offset = new Point(-11, -11);\n        iconMarker.Tag = id;\n        iconMarker.Shape = shape;\n    }\n    mapControl.Markers.Add(iconMarker);\n}\n```\n关键代码：\n```C#\nTooltipForMap content = new TooltipForMap(tooltip, tooltipViewer);\n```\n其中TooltipForMap类的SizeChanged函数如下：\n```C#\nprivate void TooltipForMap_SizeChanged(object sender, SizeChangedEventArgs e)\n{\n    _TooltipViewer.Offset = new Point(-ActualWidth / 2, -ActualHeight - 22);\n}\n```\n_TooltipViewer和传入构造函数的tooltipViewer为同一实例。\n*持续更新中...*","tags":["GMap.net"],"categories":["software"]},{"title":"Android学习心得","url":"/2017/08/19/Android学习心得/","content":"** 参加四维图新地图制图大赛，写了个了Android App，现在把学到的知识记录一下 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n","tags":["AndroidStudio"],"categories":["language"]},{"title":"GIS-for-Web应用开发之道-学习心得","url":"/2017/08/19/GIS-for-Web应用开发之道-学习心得/","content":"** GIS-for-Web应用开发之道 读书心得 ** <Excerpt in index | 首页摘要>\n    在此感谢[康导](GIS-for-Web应用开发之道 \"Chaogui Kang\")的指导\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["GIS"],"categories":["web"]},{"title":"git学习心得","url":"/2017/08/19/git学习心得/","content":"** git命令行学习小记 ** <Excerpt in index | 首页摘要>\n    利用git命令行托管代码到github，搭建自己的git服务\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["Git"],"categories":["software"]},{"title":"在VS中使用Github","url":"/2017/08/19/在VS中使用Github/","content":"** vs中使用GitHub的方法 ** <Excerpt in index | 首页摘要>\n    将VS工程代码提交到github或自己的git服务\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["VS"],"categories":["software"]},{"title":"Github使用指南","url":"/2017/08/19/Github使用指南/","content":"** 前几个月学习了Github的使用，希望我的经验能帮助到所有希望了解Github的人 ** <Excerpt in index | 首页摘要>\n    感谢在我迷惑的时候有[师兄](https://github.com/HPDell \"HPDell\")的指点\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["Git"],"categories":["software"]},{"title":"C#中await和async","url":"/2017/08/19/C-中await和async/","content":"** C#中await和async使用介绍 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n","tags":["C#"],"categories":["language"]},{"title":"Wpf使用MahApp.Metro主题","url":"/2017/08/19/Wpf使用MahApp-Metro主题/","content":"** Wpf使用MahApp.Metro主题的步骤小记 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["Xaml"],"categories":["language"]},{"title":"2017年暑假旅游笔记","url":"/2017/08/17/暑假旅游笔记/","content":"** 暑假旅行笔记 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n## 起点：彭水\n持续更新...\n## 第一站：涪陵\n持续更新...\n## 第二站：重庆\n持续更新...\n## 第三站：成都\n持续更新...\n## 第四站：重庆\n持续更新...\n## 终点：彭水\n持续更新...\n","categories":["Life"]},{"title":"ISODATA算法学习心得及非监督分类软件得商业化界面实现","url":"/2017/08/17/ISODATA算法学习心得及非监督分类软件得商业化界面实现/","content":"** ISODATA和Winform ** <Excerpt in index | 首页摘要>\n    [姚剑老师](http://www.scholat.com/jianyao \"Jian Yao\")模式识别作业，代码已托管至[Github](https://github.com/CS-Tao/ImageFactory \"ImageFactory\")\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### ISODATA算法介绍\nISODATA(Iterative Selforganizing Data Analysis Techniques Algorithm)算法，即迭代自组织数据分析算法。该算法是在k-均值算法的基础上，增加对聚类结果的“合并”和“分裂”两个操作，并设定算法运行控制参数的一种聚类算法。迭代次数会影响最终结果，迭代参数选择很重要。待续...\n### 商业化界面的实现\n采用Winform实现。待续...","tags":["ISODATA"],"categories":["software"]}]