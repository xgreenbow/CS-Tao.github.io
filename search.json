[{"title":"解决C#发送电子邮件失败的问题","url":"/2017/10/18/解决C-发送电子邮件失败的问题/","content":"\n## 源码\n- EmailHelper.cs文件内容\n\n```C#\nusing System;\nusing System.Text;\nusing System.Net.Mail;\nusing static System.Configuration.ConfigurationManager;\n\nnamespace View_Spot_of_City.UIControls.Helper\n{\n    public static class EmailHelper\n    {\n        public static bool SendEmail(string mail, string title, string content)\n        {\n            MailMessage message = new MailMessage();\n            {\n                message.To.Add(mail);\n                message.From = new MailAddress(AppSettings[\"MANAGER_MAIL_NUM\"], AppSettings[\"MANAGER_MAIL_NAME\"], Encoding.UTF8);\n                message.Subject =title;\n                message.SubjectEncoding = Encoding.UTF8;\n                message.Body = content;\n                message.BodyEncoding = Encoding.UTF8;\n                message.IsBodyHtml = false;\n                message.Priority = MailPriority.Normal;\n            }\n\n            SmtpClient smtp = new SmtpClient();\n            {\n                smtp.Host = AppSettings[\"SmtpClient_HOST\"];\n                smtp.EnableSsl = true;\n                smtp.UseDefaultCredentials = false;\n                smtp.Credentials = new System.Net.NetworkCredential(AppSettings[\"MANAGER_MAIL_NUM\"], AppSettings[\"MANAGER_MAIL_PASSWORD\"]);\n            }\n            object userState = message;\n            try\n            {\n                smtp.SendAsync(message, userState);\n                return true;\n            }\n            catch(Exception ex)\n            {\n                Console.Write(ex.Message);\n                return false;\n            }\n        }\n    }\n}\n```\n- 配置文件App.Config内容\n    - 添加``程序集的引用\n    - 在App.Config文件中添加键值，如下（只需要关注appSettings标签内的内容）\n    ```xml\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <configSections>\n    <section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=*************\" requirePermission=\"false\" />\n    <!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 -->\n  </configSections>\n  <startup>\n    <supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5.2\" />\n  </startup>\n  <appSettings>\n  <!--邮箱-->\n    <add key=\"MANAGER_MAIL_NUM\" value=\"123456789@qq.com\" />\n    <!--邮箱密码-->\n    <add key=\"MANAGER_MAIL_PASSWORD\" value=\"邮箱密码，QQ邮箱需要许可码\" />\n    <!--邮件显示名-->\n    <add key=\"MANAGER_MAIL_NAME\" value=\"发送邮件使用的用户名\" />\n    <!--QQ邮箱对应的SMTP服务器-->\n    <add key=\"SmtpClient_HOST\" value=\"smtp.qq.com\"/>\n  </appSettings>\n</configuration>\n    ```\n\n## 注意\n若使用QQ邮箱，输入密码为许可码，需要在QQ邮箱中打开SMTP服务\n- 打开QQ邮箱网页版\n- 点击左上角“设置”，并在导航栏中点击账户标签\n- 开启SMTP服务并获得许可码\n    ![开启SMTP服务](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/WpfSendMail.png)","tags":["Wpf"],"categories":["software"]},{"title":"WPF自定义消息框","url":"/2017/10/18/WPF自定义消息框/","content":"** 一个语言文化的的WPF消息框 ** <Excerpt in index | 首页摘要>\n消息框采用Material风格，支持中英切换，支持的返回值有Ok、Cancel、Yes、No，代码已托管并发布至[Github](https://github.com/CS-Tao/MyMessageBox/releases/tag/v1.0)\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 效果预览\n- 带OK按钮的消息框<br>\n![带OK按钮的消息框](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/MyMessagebox/MyMessageBox_OK1.png)\n![带OK按钮的消息框](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/MyMessagebox/MyMessageBox_OK2.png)\n- 带OK和取Cancel按钮的消息框<br>\n![带OK和取Cancel按钮的消息框](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/MyMessagebox/MyMessageBox_OKCancel1.png)\n![带OK和取Cancel按钮的消息框](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/MyMessagebox/MyMessageBox_OKCancel2.png)\n- 带Yes和No按钮的消息框<br>\n![带Yes和No按钮的消息框](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/MyMessagebox/MyMessageBox_YesNo1.png)\n![带Yes和No按钮的消息框](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/MyMessagebox/MyMessageBox_YesNo2.png)\n- 带Yes、No和Cancel按钮的消息框<br>\n![带Yes、No和Cancel按钮的消息框](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/MyMessagebox/MyMessageBox_YesNoCancel1.png)\n![带Yes、No和Cancel按钮的消息框](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/MyMessagebox/MyMessageBox_YesNoCancel2.png)\n\n## 使用方法\n### 首先\n- 引用本消息框所在程序集。\n- 在App.xaml文件中添加：<br>\n```xml\n<ResourceDictionary Source=\"pack://application:,,,/CSTao.MessageBox;component/Resources.xaml\"/>\n```<br>\n如下：<br>\n![添加资源字典](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/MyMessagebox/MessageBoxResoureCode.png)\n\n### 使用MessageBox\n- 在程序中需要使用的地方添加命名空间：<br>\n```C#\nusing CSTao.MessageBox;\n```\n- 调用MessageboxMaster.Show()函数，该函数有多个重载，请按您的需求使用。\n### 使用语言切换\n- 静态修改<br>\n将`MyMessageBox\\MyMessagebox\\CSTao.MessageBox\\Languages\\LanguagesDictionary.xaml`中的`Language.CN.xaml`改为`Language.EN.xaml`即可。\n- 动态修改<br>\n在您定义的修改语言的响应函数中添加代码<br>\n```C#\nstring requestedCulture = string.Format(@\"pack://application:,,,/CSTao.MessageBox;component/Languages/Language.{0}.xaml\", languageDictionary[0或1]);\nResourceDictionary resourceDictionary = Application.Current.Resources.MergedDictionaries.FirstOrDefault((x) =>\n{\n    return (x.Source == null) ? false : (x.Source.OriginalString.Contains(\"CSTao.MessageBox;component/Languages\"));\n});\nif (resourceDictionary != null)\n{\n    Application.Current.Resources.MergedDictionaries.Remove(resourceDictionary);\n    ResourceDictionary requestDictionary = new ResourceDictionary()\n    {\n        Source = new Uri(requestedCulture)\n    };\n    Application.Current.Resources.MergedDictionaries.Add(requestDictionary);\n}\n```<br>\n`温馨提醒:`本方法是笔者用于全局改变软件语言的代码，不仅针对本消息框，慎用\n\n### 修改主题颜色\n修改`MyMessageBox\\MyMessagebox\\CSTao.MessageBox\\Resources.xaml`中`PrimaryHueBrush`键的值即可\n\n## 特别感谢\n感谢[师兄](https://hpdell.github.io/)提供的代码参考。","tags":["Wpf"],"categories":["software"]},{"title":"关于带登录界面的WPF应用的问题","url":"/2017/10/11/关于带登录界面的WPF应用的问题/","content":"** 解决WPF关闭登录窗口后主窗口无法打开的问题 ** <Excerpt in index | 首页摘要>\n    笔者最近在开发一款[WPF应用程序](https://github.com/CS-Tao/View-Spot-of-City)的时候，发现在登录窗口关闭之后，主窗口无法打开，遂上网搜索了一下，找到了问题所在\n<!-- more -->\n<The rest of contents | 余下全文>\n## 问题描述\n笔者通过重载App类OnStartup()函数，在其中添加了启动登录框的代码：\n```C#\nprotected override void OnStartup(StartupEventArgs e)\n{\n    //验证License\n    if (!RegisterMaster.CanStart())\n    {\n        Environment.Exit(0);\n    }\n    \n    //登录\n    bool? loginDlgResult = (new LoginDlg()).ShowDialog();\n    if (!loginDlgResult.HasValue || !loginDlgResult.Value)\n        Environment.Exit(0);\n\n    base.OnStartup(e);\n}\n```\n却发现登录窗口关闭后不能启动主窗口（也就是WPF自动生成的MainWindow类对应的窗口）。\n## 解决方法\n将App的ShutdownMode属性改为OnExplicitShutdown即可：\n```C#\nprotected override void OnStartup(StartupEventArgs e)\n{\n    //应用程序关闭时，才System.Windows.Application.Shutdown调用\n    this.ShutdownMode = ShutdownMode.OnExplicitShutdown;\n\n    //验证License\n    if (!RegisterMaster.CanStart())\n    {\n        Environment.Exit(0);\n    }\n    \n    //登录\n    bool? loginDlgResult = (new LoginDlg()).ShowDialog();\n    if (!loginDlgResult.HasValue || !loginDlgResult.Value)\n        Environment.Exit(0);\n\n    base.OnStartup(e);\n}\n```\n`注意：`需要关闭应用程序时需要显示调用System.Windows.Application.Shutdown()函数，或其他退出程序的函数。\n## 出现问题的原因\n由上我们可以看出问题的根源就是App的ShutdownMode属性，那么这个属性有什么意义呢？<br>\n我们可以很容易地知道ShutdownMode是一个枚举属性，其可能得取值有三个，分别是OnLastWindowClose、OnMainWindowClose、OnExplicitShutdown。<br>进一步探索笔者发现ShutdownMode属性的默认值为OnLastWindowClose，也就是WPF会在最后一个窗口关闭时隐式调用Application的Shutdown()函数，对此MSDN中有提到：https://msdn.microsoft.com/zh-cn/subscriptions/system.windows.application.shutdownmode(v=vs.100).aspx<br>\n>如果将 ShutdownMode 设置为 OnLastWindowClose，则 Windows Presentation Foundation (WPF) 会在应用程序中的最后一个窗口关闭时隐式调用 Shutdown，即使任何当前已经实例化的窗口被设置为主窗口也是如此。请参见 https://msdn.microsoft.com/zh-cn/subscriptions/system.windows.application.mainwindow(v=vs.100).aspx\n\nWPF会把第一个在AppDomain中实例化的第一个Window对象的引用，自动设置为应用程序的主窗口，也就是说当登录框实例化的时候，就被设置为主窗口了。且当登录窗口关闭时，没有任何其他的窗口处于显示状态，满足`OnLastWindowClose`的退出条件，WPF会隐式调用ShutDown()，以至于真正的主窗口无法显示。","tags":["Wpf"],"categories":["software"]},{"title":"Android工具包-xUtils基本使用","url":"/2017/09/21/Android工具包-xUtils基本使用/","content":"** xUtils基本使用 ** <Excerpt in index | 首页摘要>\n    本文转自[开源中国](http://www.oschina.net/p/xutils?fromerr=FllYBeuf \"查看原文\")，因为原文的markdown格式出于某种原因未渲染，笔者将其转到了自己博客，方便查看\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## xUtils3简介\n* xUtils 包含了orm, http(s), image, view注解, 但依然很轻量级(246K), 并且特性强大, 方便扩展:\n  - `稳定的基石`: `AbsTask`和统一的回调接口`Callback`, 任何异常, 即使你的回调方法实现有异常都会进入`onError`, 任何情况下`onFinished`总会让你知道任务结束了.\n  - 基于高效稳定的`orm`工具, `http`模块得以更方便的实现cookie(支持domain, path, expiry等特性)和\n    缓存(支持Cache-Control, Last-Modified, ETag等特性)的支持.\n  - 有了强大的`http`及其下载缓存的支持, `image`模块的实现相当的简洁, 并且支持回收被view持有, 但被Mem Cache移除的图片, 减少页面回退时的闪烁..\n  - `view`注解模块仅仅400多行代码却灵活的支持了各种View注入和事件绑定, 包括拥有多了方法的listener的支持.\n\n### 其他特性\n* 支持超大文件(超过2G)上传\n* 更全面的http请求协议支持(11种谓词)\n* 拥有更加灵活的ORM, 和greenDao一致的性能\n* 更多的事件注解支持且不受混淆影响...\n* 图片绑定支持gif(受系统兼容性影响, 部分gif文件只能静态显示), webp; 支持圆角, 圆形, 方形等裁剪, 支持自动旋转...\n* 从3.5.0开始不再包含libwebpbackport.so, 需要在Android4.2以下设备兼容webp的请使用3.4.0版本.\n\n#### 使用Gradle构建时添加一下依赖即可:\n```javascript\ncompile 'org.xutils:xutils:3.5.0'\n```\n##### 如果使用eclipse可以 [点击这里下载aar文件](http://dl.bintray.com/wyouflf/maven/org/xutils/xutils/), 然后用zip解压, 取出jar文件.\n##### 混淆配置参考示例项目sample的配置\n\n\n#### 常见问题:\n1. 更好的管理图片缓存: https://github.com/wyouflf/xUtils3/issues/149\n2. Cookie的使用: https://github.com/wyouflf/xUtils3/issues/125\n3. 关于query参数? http请求可以通过 header, url, body(请求体)传参; query参数是url中问号(?)后面的参数.\n4. 关于body参数? body参数只有PUT, POST, PATCH, DELETE(老版本RFC2616文档没有明确指出它是否支持, 所以暂时支持)请求支持.\n5. 自定义Http参数对象和结果解析: https://github.com/wyouflf/xUtils3/issues/191\n\n#### 使用前配置\n##### 需要的权限\n```xml\n\n\n```\n##### 初始化\n```java\n// 在application的onCreate中初始化\n@Override\npublic void onCreate() {\n    super.onCreate();\n    x.Ext.init(this);\n    x.Ext.setDebug(BuildConfig.DEBUG); // 是否输出debug日志, 开启debug会影响性能.\n    ...\n}\n```\n\n### 使用@Event事件注解(@ContentView, @ViewInject等更多示例参考sample项目)\n```java\n/**\n * 1. 方法必须私有限定,\n * 2. 方法参数形式必须和type对应的Listener接口一致.\n * 3. 注解参数value支持数组: value={id1, id2, id3}\n * 4. 其它参数说明见{@link org.xutils.event.annotation.Event}类的说明.\n **/\n@Event(value = R.id.btn_test_baidu1,\n        type = View.OnClickListener.class/*可选参数, 默认是View.OnClickListener.class*/)\nprivate void onTestBaidu1Click(View view) {\n...\n}\n```\n\n### 访问网络(更多示例参考sample项目)\n```java\n/**\n * 自定义实体参数类请参考:\n * 请求注解 {@link org.xutils.http.annotation.HttpRequest}\n * 请求注解处理模板接口 {@link org.xutils.http.app.ParamsBuilder}\n *\n * 需要自定义类型作为callback的泛型时, 参考:\n * 响应注解 {@link org.xutils.http.annotation.HttpResponse}\n * 响应注解处理模板接口 {@link org.xutils.http.app.ResponseParser}\n *\n * 示例: 查看 org.xutils.sample.http 包里的代码\n */\nBaiduParams params = new BaiduParams();\nparams.wd = \"xUtils\";\n// 有上传文件时使用multipart表单, 否则上传原始文件流.\n// params.setMultipart(true);\n// 上传文件方式 1\n// params.uploadFile = new File(\"/sdcard/test.txt\");\n// 上传文件方式 2\n// params.addBodyParameter(\"uploadFile\", new File(\"/sdcard/test.txt\"));\nCallback.Cancelable cancelable\n       = x.http().get(params,\n       /**\n        * 1. callback的泛型:\n        * callback参数默认支持的泛型类型参见{@link org.xutils.http.loader.LoaderFactory},\n        * 例如: 指定泛型为File则可实现文件下载, 使用params.setSaveFilePath(path)指定文件保存的全路径.\n        * 默认支持断点续传(采用了文件锁和尾端校验续传文件的一致性).\n        * 其他常用类型可以自己在LoaderFactory中注册,\n        * 也可以使用{@link org.xutils.http.annotation.HttpResponse}\n        * 将注解HttpResponse加到自定义返回值类型上, 实现自定义ResponseParser接口来统一转换.\n        * 如果返回值是json形式, 那么利用第三方的json工具将十分容易定义自己的ResponseParser.\n        * 如示例代码{@link org.xutils.sample.http.BaiduResponse}, 可直接使用BaiduResponse作为\n        * callback的泛型.\n        *\n        * 2. callback的组合:\n        * 可以用基类或接口组合个种类的Callback, 见{@link org.xutils.common.Callback}.\n        * 例如:\n        * a. 组合使用CacheCallback将使请求检测缓存或将结果存入缓存(仅GET请求生效).\n        * b. 组合使用PrepareCallback的prepare方法将为callback提供一次后台执行耗时任务的机会,\n        * 然后将结果给onCache或onSuccess.\n        * c. 组合使用ProgressCallback将提供进度回调.\n        * ...(可参考{@link org.xutils.image.ImageLoader}\n        * 或 示例代码中的 {@link org.xutils.sample.download.DownloadCallback})\n        *\n        * 3. 请求过程拦截或记录日志: 参考 {@link org.xutils.http.app.RequestTracker}\n        *\n        * 4. 请求Header获取: 参考 {@link org.xutils.http.app.RequestInterceptListener}\n        *\n        * 5. 其他(线程池, 超时, 重定向, 重试, 代理等): 参考 {@link org.xutils.http.RequestParams}\n        *\n        **/\n       new Callback.CommonCallback() {\n           @Override\n           public void onSuccess(String result) {\n               Toast.makeText(x.app(), result, Toast.LENGTH_LONG).show();\n           }\n\n           @Override\n           public void onError(Throwable ex, boolean isOnCallback) {\n               //Toast.makeText(x.app(), ex.getMessage(), Toast.LENGTH_LONG).show();\n               if (ex instanceof HttpException) { // 网络错误\n                   HttpException httpEx = (HttpException) ex;\n                   int responseCode = httpEx.getCode();\n                   String responseMsg = httpEx.getMessage();\n                   String errorResult = httpEx.getResult();\n                   // ...\n               } else { // 其他错误\n                   // ...\n               }\n               Toast.makeText(x.app(), ex.getMessage(), Toast.LENGTH_LONG).show();\n           }\n\n           @Override\n           public void onCancelled(CancelledException cex) {\n               Toast.makeText(x.app(), \"cancelled\", Toast.LENGTH_LONG).show();\n           }\n\n           @Override\n           public void onFinished() {\n\n           }\n       });\n\n// cancelable.cancel(); // 取消请求\n```\n#### 如果你只需要一个简单的版本:\n```java\n@Event(value = R.id.btn_test_baidu2)\nprivate void onTestBaidu2Click(View view) {\n    RequestParams params = new RequestParams(\"https://www.baidu.com/s\");\n    params.setSslSocketFactory(...); // 设置ssl\n    params.addQueryStringParameter(\"wd\", \"xUtils\");\n    x.http().get(params, new Callback.CommonCallback() {\n        @Override\n        public void onSuccess(String result) {\n            Toast.makeText(x.app(), result, Toast.LENGTH_LONG).show();\n        }\n\n        @Override\n        public void onError(Throwable ex, boolean isOnCallback) {\n            Toast.makeText(x.app(), ex.getMessage(), Toast.LENGTH_LONG).show();\n        }\n\n        @Override\n        public void onCancelled(CancelledException cex) {\n            Toast.makeText(x.app(), \"cancelled\", Toast.LENGTH_LONG).show();\n        }\n\n        @Override\n        public void onFinished() {\n\n        }\n    });\n}\n````\n#### 带有缓存的请求示例:\n```java\nBaiduParams params = new BaiduParams();\nparams.wd = \"xUtils\";\n// 默认缓存存活时间, 单位:毫秒.(如果服务没有返回有效的max-age或Expires)\nparams.setCacheMaxAge(1000 * 60);\nCallback.Cancelable cancelable\n       // 使用CacheCallback, xUtils将为该请求缓存数据.\n      = x.http().get(params, new Callback.CacheCallback() {\n\n   private boolean hasError = false;\n   private String result = null;\n\n   @Override\n   public boolean onCache(String result) {\n      // 得到缓存数据, 缓存过期后不会进入这个方法.\n      // 如果服务端没有返回过期时间, 参考params.setCacheMaxAge(maxAge)方法.\n        //\n        // * 客户端会根据服务端返回的 header 中 max-age 或 expires 来确定本地缓存是否给 onCache 方法.\n        //   如果服务端没有返回 max-age 或 expires, 那么缓存将一直保存, 除非这里自己定义了返回false的\n        //   逻辑, 那么xUtils将请求新数据, 来覆盖它.\n        //\n        // * 如果信任该缓存返回 true, 将不再请求网络;\n        //   返回 false 继续请求网络, 但会在请求头中加上ETag, Last-Modified等信息,\n        //   如果服务端返回304, 则表示数据没有更新, 不继续加载数据.\n        //\n        this.result = result;\n        return false; // true: 信任缓存数据, 不在发起网络请求; false不信任缓存数据.\n   }\n\n   @Override\n   public void onSuccess(String result) {\n      // 注意: 如果服务返回304 或 onCache 选择了信任缓存, 这时result为null.\n        if (result != null) {\n          this.result = result;\n      }\n   }\n\n   @Override\n   public void onError(Throwable ex, boolean isOnCallback) {\n      hasError = true;\n      Toast.makeText(x.app(), ex.getMessage(), Toast.LENGTH_LONG).show();\n      if (ex instanceof HttpException) { // 网络错误\n         HttpException httpEx = (HttpException) ex;\n         int responseCode = httpEx.getCode();\n         String responseMsg = httpEx.getMessage();\n         String errorResult = httpEx.getResult();\n         // ...\n      } else { // 其他错误\n         // ...\n      }\n   }\n\n   @Override\n   public void onCancelled(CancelledException cex) {\n      Toast.makeText(x.app(), \"cancelled\", Toast.LENGTH_LONG).show();\n   }\n\n   @Override\n   public void onFinished() {\n      if (!hasError && result != null) {\n         // 成功获取数据\n         Toast.makeText(x.app(), result, Toast.LENGTH_LONG).show();\n      }\n   }\n});\n```\n\n### 使用数据库(更多示例参考sample项目)\n```java\nParent test = db.selector(Parent.class).where(\"id\", \"in\", new int[]{1, 3, 6}).findFirst();\nlong count = db.selector(Parent.class).where(\"name\", \"LIKE\", \"w%\").and(\"age\", \">\", 32).count();\nList testList = db.selector(Parent.class).where(\"id\", \"between\", new String[]{\"1\", \"5\"}).findAll();\n```\n\n### 绑定图片(更多示例参考sample项目)\n```java\nx.image().bind(imageView, url, imageOptions);\n\n// assets file\nx.image().bind(imageView, \"assets://test.gif\", imageOptions);\n\n// local file\nx.image().bind(imageView, new File(\"/sdcard/test.gif\").toURI().toString(), imageOptions);\nx.image().bind(imageView, \"/sdcard/test.gif\", imageOptions);\nx.image().bind(imageView, \"file:///sdcard/test.gif\", imageOptions);\nx.image().bind(imageView, \"file:/sdcard/test.gif\", imageOptions);\n\nx.image().bind(imageView, url, imageOptions, new Callback.CommonCallback() {...});\nx.image().loadDrawable(url, imageOptions, new Callback.CommonCallback() {...});\n// 用来获取缓存文件\nx.image().loadFile(url, imageOptions, new Callback.CommonCallback() {...});\n```\n\n----\n### 关于作者\n* Email： , \n* 有任何建议或者使用中遇到问题都可以给我发邮件, 你也可以加入QQ群：330445659(已满), 275967695, 257323060,\n384426013, 176778777, 169852490, 261053948, 330108003, 技术交流，idea分享 *_*","tags":["xUtils"],"categories":["software"]},{"title":"Js利用百度地图API进行坐标转换","url":"/2017/09/04/Js利用百度API进行坐标转换/","content":"** 百度地图API for JavaScript的使用 **<Excerpt in index | 首页摘要>\n在Js中利用百度地图API对地理坐标系和投影坐标系（墨卡托）进行互转\n<!-- more -->\n<The rest of contents | 余下全文>\n## 导入js文件\n在html文件中添加<br>\n```javascript\n<script src=\"http://api.map.baidu.com/api?v=1.2\"></script>\n```\n## 地理坐标转为平面坐标\n```javascript\nvar projection = new BMap.MercatorProjection();\nvar mercatorPoint = projection.lngLatToPoint(new BMap.Point(114.3908, 30.4879));\nalert(\"x = \" + mercatorPoint.x + \", y = \" + mercatorPoint.y);\n```\n## 平面坐标转为地理坐标\n```javascript\nvar projection = new BMap.MercatorProjection();\nvar lngLat = projection.pointToLngLat(new BMap.Pixel(12734064.16, 3544542.8));\nalert(\"lng = \" + lngLat.lng + \", lat = \" + lngLat.lat);\n```","tags":["百度API"],"categories":["language"]},{"title":"夜跑助手App-路径规划的实现","url":"/2017/09/03/夜跑助手App-路径规划的实现/","content":"** [夜跑助手App](https://github.com/CS-Tao/Route-NightRun)路径规划的实现 ** <Excerpt in index | 首页摘要>\n    夜跑助手App是我们小组参加四维图新地图制图大赛的成果之一，现在对其中的夜跑路径规划的方式进行记录\n<!-- more -->\n<The rest of contents | 余下全文>\n## 按站点进行路径规划\n### 原理和方法\n按站点进行路径规划的方式主要是利用[GraphHopper](https://www.graphhopper.com/)提供的WebAPI进行路径规划，通过对Rest接口发送Get请求获取json数据，如[示例](https://graphhopper.com/api/1/route?point=49.932707,11.588051&point=50.3404,11.64705&vehicle=car&debug=false&key=f8821850-c1f8-4f8f-befb-f976c887ebfb&optimize=true)。\n\n### 具体实现\n- 通过用户在手机屏幕上的双击操作获得用户希望经过的站点并进行标记\n- 在用户指定的站点链表的首位加上用户位置\n- 将上一步产生的站点列表投影为地理坐标\n- 生成http请求\n- 得到返回的json数据\n- 解析数据，此时便可得到路径信息\n- 将路径显示到屏幕上\n- 同时计算路径附近两百米形成的地理坐标框，发送http请求到我们自己的服务器\n- 得到饮品店信息并进行显示\n\n流程图如下：<br>\n![流程图](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E7%AB%99%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92.png)<br>\n效果图如下：<br>\n![App截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E7%AB%99%E7%82%B9%E8%A7%84%E5%88%92%E8%B7%AF%E5%BE%841.jpg)<br>\n![App截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E7%AB%99%E7%82%B9%E8%A7%84%E5%88%92%E8%B7%AF%E5%BE%842.jpg)<br>\n\n## 按路径长度进行路径规划\n### 原理和方法\n按路径长度进行路径规划相比于按站点的路径规划显得更加复杂，需要预定若干站点，并对符合预定要求的站点依次利用GraphHopper的Rest接口计算最短距离，接着得到与指定路径长度的一半最接近的距离和其对应的站点，最后通过GraphHopper得到最短路径。\n\n### 具体实现\n`注意：`夜跑区域的站点数据，由App维护人员通过其他软件采集并上传到数据库，软件已托管至[Github](https://github.com/CS-Tao/DataAcquisitionForNightRunning)。\n- 用户输入路径长度，设为a\n- 得到以用户为中心周围a/4到a/2区域内的所有站点\n- 依次利用GraphHopper的最短路径接口发送http请求，并获得用户位置到上一步所有站点的路径距离\n- 将这些距离值与与a/2比较，得到与a/2最接近的距离，并记录其对应的站点\n- 通过发送http请求获得用户位置到该站点的最短路径\n- 解析数据并显示路径\n- 显示附近的饮品店，和之前的方式一样，在此不详述\n\n流程图如下：<br>\n![流程图](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E8%BF%9B%E8%A1%8C%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92.png)<br>\n效果图如下：<br>\n![App截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E8%BF%9B%E8%A1%8C%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%921.png)<br>\n![App截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E8%BF%9B%E8%A1%8C%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%922.png)<br>\n## 结束语\n按指定站点进行路径规划得到的是环形回路，按指定路径长度得到的是一条供往返的线路。笔者思考了很久，最终采用了如上文叙述的方法进行按路径长度规划路径，如果您有更好的方法，无论是算法还是工具，希望您能在评论中指出，共同进步，非常感谢。","tags":["WebAPI"],"categories":["software"]},{"title":"Ubuntu系统下的PostgreSQL安装和配置","url":"/2017/09/02/Ubuntu系统下的PostgreSQL安装和配置/","content":"** Ubuntu 16.04系统下的PostgreSQL 9.6安装和配置的详细步骤 ** <Excerpt in index | 首页摘要>\nPostgreSQL 是一个自由的对象-关系数据库服务器(数据库管理系统)，它在 BSD-风格许可证下发行\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## PostgreSQL介绍\n[PostgreSQL](https://www.postgresql.org/)是以加州大学伯克利分校计算机系开发的 POSTGRES，现在已经更名为PostgreSQL，版本 4.2为基础的对象关系型数据库管理系统（ORDBMS），开发语言为C/C++。PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。\n\n## PostgresSQL安装\n- 添加apt-repository\n    ```Bash\n    sudo add-apt-repository \"deb http://apt.postgresql.org/pub/repos/apt/ xenial-pgdg main\"\n    ```\n- 载入apt-repository的签名\n    ```Bash\n    wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -\n    ```\n- 更新package列表\n    ```Bash\n    sudo apt-get update\n    ```\n- 通过apt-get工具安装PostgreSQL\n    ```Bash\n    apt-get install postgresql-9.6\n    ```\n    \n## 配置PostgreSQL\n- 切换到postgres用户\n    ```Bash\n    sudo su postgres\n    ```\n- 登录到postgresql\n    ```Bash\n    psql postgres\n    ```\n    如果看到如下页面则说明之前的努力没有白费，已经安装成功了。<br>\n    ![Putty截图](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/PostgreSQL%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png)\n- 更改用户密码\n    在当前界面下输入\n    ```Bash\n    \\password\n    ```\n    输入你想设置的PostgreSQL密码。输入\\q回车退出。\n- 设置连接权限\n    - 打开配置文件\n        ```Bash\n        vim /etc/postgresql/9.1/main/postgresql.conf\n        ```\n    - 修改连接权限为所有主机\n        ```Bash\n        #listen_addresses = ‘localhost’改为 listen_addresses = ‘*’\n        ```\n        `注意：`需要去掉#号\n    - 启用密码验证\n        ```Bash\n        #password_encryption = on 改为 password_encryption = on\n        ```\n        `注意：`需要去掉#号\n- 设置用户ip段\n    - 打开配置文件\n        ```Bash\n        vim /etc/postgresql/9.1/main/pg_hba.conf\n        ```\n    - 在文件末尾添加如下内容\n        ```Bash\n        host all all 0.0.0.0/0 md5\n        ```\n        `注意：`0.0.0.0为地址段。0为掩码的二进制位，可取数值为0、8、16、24、32。md5为加密方式\n        `示例：`192.168.0.0/16代表192.168.0.1 ~ 192.168.255.254\n- 重启PostgreSQL服务\n    ```Bash\n    sudo service postgres restart\n    ```\n    \n## 登录数据库\n- 本地登录\n    ```Bash\n    psql -U postgres -h 127.0.0.1\n    ```\n- 远程登录\n    ```Bash\n    psql -U postgres -h 远程IP地址\n    ```","tags":["Ubuntu"],"categories":["software"]},{"title":"如何利用hexo发表文章","url":"/2017/08/24/如何利用hexo发表文章/","content":"** 如何利用hexo发表文章 ** <Excerpt in index | 首页摘要>\n    本文修改自[Hexo](https://hexo.io/)自动创建的Hello-World.md，Hexo代码开源。详见[GitHub](https://github.com/hexojs/hexo/)\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 新建文章并发表\n\n## 新建文章\n\n``` bash\n$ hexo new \"新文章\"\n```\n\n## 写文章\n详见：Hexo[官方文档](https://hexo.io/docs/writing.html)\n\n## 生成静态文件\n\n``` bash\n$ hexo generate\n```\n\n详见：Hexo[官方文档](https://hexo.io/docs/generating.html)\n\n## 启动hexo服务\n\n``` bash\n$ hexo server\n```\n\n详见：Hexo[官方文档](https://hexo.io/docs/server.html)\n\n## 部署到远程\n\n``` bash\n$ hexo deploy\n```\n\nHexo[官方文档](https://hexo.io/docs/deployment.html)\n","tags":["Hexo"],"categories":["web"]},{"title":"GMap.net for WPF 使用心得","url":"/2017/08/19/GMap.net-for-WPF-使用心得/","content":"** GMap.net for WPF ** <Excerpt in index | 首页摘要>\n    利用GMap.net for WPF绘制点线面的方式以及未指定长宽的要素与其他要素间相对定位的方式\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## GMap.net概述\n[GMap.net](https://greatmaps.codeplex.com/ \"进入GMap.NET的项目地址\")是一个强大、免费、跨平台、开源的.NET控件，它在WinForm和WPF环境中能够通过Google, Yahoo!, Bing, OpenStreetMap, ArcGIS, Pergo, SigPac等实现寻找路径、地理编码以及地图展示功能，并支持缓存和运行在Mobile环境中。<br>GMap.NET是一个开源的GEO地图定位和跟踪程序。就像谷歌地图、雅虎地图一样，可以自动计算两地的距离，定位经纬度，与Google地图不同的是，该项目是建立在WinForm框架或WPF框架基础上的。可以对地图放大缩小，进行城市标记等。\n  <br>\n## GMap.net for WPF 绘制要素\n因为现在正在利用GMap.net for WPF写一个项目，所以我对WPF版本更加熟悉，如有错误或不当之处，还望指出，共同进步！\n\n* 不同于Winform版本，WPF版本没有图层的概念，但用于显示要素的对象GMapMarker提供了Zindex属性，该属性值大的会遮盖属性值小的。所以大家可以利用Zindex对地理要素建立逻辑上的图层关联。\n \n* WinForm版本绘图可以直接在显示对象上设置图形的属性，如：\n    ```C#\n    GMapPolygon polygon = new GMapPolygon(pointList, \"Polygon\");\n    {\n        polygon.IsHitTestVisible = true;\n        polygon.Fill = new SolidBrush(Color.FromArgb(50, Color.Red));\n        polygon.Stroke = new Pen(Color.Blue, 2);\n    }\n    overlay.Polygons.Add(polygon);\n    ```\n    对于wpf版本的点对象，可以直接指定显示用户控件，如：<br>\n    ```C#\n    GMapMarker marker = new GMapMarker(pointLatLng);\n    {\n        MyUserControl myUserControl = new MyUserControl()\n        marker.Shape = myUserControl;\n        marker.ZIndex = (int)LayerIndex.Point;\n        marker.Offset = new Point(-myUserControl.ActualWidth / 2, -myUserControl.ActualHeight / 2);\n    }\n    mapControl.Markers.Add(marker);\n    ```\n    其中MyUserControl可以重载自UserControl，并自定义显示内容。LayerIndex为自定义的枚举类型。mapControl重载自GMapControl。\n    但是wpf版本的线的属性设置需要重载GMapControl的CreateRoutePath方法，面的属性设置需要重载CreatePolygonPath方法。为了不影响原函数的内容，我们可以参考GMapControl的源代码[*GMapControl.cs*](https://greatmaps.codeplex.com/SourceControl/latest#GMap.NET.WindowsPresentation/GMap.NET.WindowsPresentation/GMapControl.cs \"查看源码文件\")文件。重载CreateRoutePath方法和CreatePolygonPath后的内容如下，只做了少量修改：\n    ```C#\n    /// <summary>\n    /// creates path from list of points, for performance set addBlurEffect to false\n    /// </summary>\n    /// <param name=\"pl\"></param>\n    /// <returns></returns>\n    public override Path CreateRoutePath(List<Point> localPath, bool addBlurEffect)\n    {\n        // Create a StreamGeometry to use to specify myPath.\n        StreamGeometry geometry = new StreamGeometry();\n        \n        using (StreamGeometryContext ctx = geometry.Open())\n        {\n            ctx.BeginFigure(localPath[0], false, false);\n            \n            // Draw a line to the next specified point.\n            ctx.PolyLineTo(localPath, true, true);\n        }\n        \n        // Freeze the geometry (make it unmodifiable)\n        // for additional performance benefits.\n        geometry.Freeze();\n        \n        // Create a path to draw a geometry with.\n        Path myPath = new Path();\n        {\n            // Specify the shape of the Path using the StreamGeometry.\n            myPath.Data = geometry;\n            \n            if (addBlurEffect)\n            {\n                BlurEffect ef = new BlurEffect();\n                {\n                    ef.KernelType = KernelType.Gaussian;\n                    ef.Radius = 0.0;\n                    ef.RenderingBias = RenderingBias.Performance;\n                }\n                \n                myPath.Effect = ef;\n            }\n\n            myPath.Stroke = lineBrush;\n            myPath.StrokeThickness = lineWidth;\n            myPath.StrokeLineJoin = PenLineJoin.Round;\n            myPath.StrokeStartLineCap = PenLineCap.Triangle;\n            myPath.StrokeEndLineCap = PenLineCap.Round;\n            \n            myPath.Opacity = lineOpacity;\n            myPath.IsHitTestVisible = false;\n        }\n        return myPath;\n    }\n    ```\n    `注意:`代码中lineBrush、lineWidth、lineOpacity为重载GMapControl时新添的公共字段。\n     \n     ```C#\n    /// <summary>\n    /// creates path from list of points, for performance set addBlurEffect to false\n    /// </summary>\n    /// <param name=\"pl\"></param>\n    /// <returns></returns>\n    public override Path CreatePolygonPath(List<Point> localPath, bool addBlurEffect)\n    {\n        // Create a StreamGeometry to use to specify myPath.\n        StreamGeometry geometry = new StreamGeometry();\n\n        using (StreamGeometryContext ctx = geometry.Open())\n        {\n            ctx.BeginFigure(localPath[0], true, true);\n\n            // Draw a line to the next specified point.\n            ctx.PolyLineTo(localPath, true, true);\n        }\n\n        // Freeze the geometry (make it unmodifiable)\n        // for additional performance benefits.\n        geometry.Freeze();\n\n        // Create a path to draw a geometry with.\n        Path myPath = new Path();\n        {\n            // Specify the shape of the Path using the StreamGeometry.\n            myPath.Data = geometry;\n\n            if (addBlurEffect)\n            {\n                BlurEffect ef = new BlurEffect();\n                {\n                    ef.KernelType = KernelType.Gaussian;\n                    ef.Radius = 0.0;\n                    ef.RenderingBias = RenderingBias.Performance;\n                }\n\n                myPath.Effect = ef;\n            }\n\n            myPath.Stroke = polygonStrokeBrush;\n            myPath.StrokeThickness = polygonThickness;\n            myPath.StrokeLineJoin = PenLineJoin.Miter;\n            myPath.StrokeStartLineCap = PenLineCap.Triangle;\n            myPath.StrokeEndLineCap = PenLineCap.Square;\n\n            myPath.Fill = polygonFillBush;\n\n            myPath.Opacity = polygonOpacity;\n            myPath.IsHitTestVisible = false;\n        }\n        return myPath;\n    }\n    ```\n    `注意:`代码中polygonStrokeBrush、polygonThickness、polygonFillBush、polygonOpacity为重载GMapControl时新添的公共字段。\n* wpf版本只能绘制Point、PolyLine、Polygon三种图形，绘制圆则需要借助多边形的绘制。示例如下：\n    ```C#\n    public void DrawCircle(PointLatLng center, double R)\n    {\n        double cartesianCenterX = double.MaxValue;\n        double cartesianCenterY = double.MaxValue;\n        double cartesianCenterZ = double.MaxValue;\n\n        mapControl.MapProvider.Projection.FromGeodeticToCartesian(center.Lat, center.Lng, 0, out cartesianCenterX, out cartesianCenterY, out cartesianCenterZ);//将圆心投影到笛卡尔坐标系\n\n        int pointCount = 200;//用于拟合圆的多边形顶点个数\n\n        List<PointLatLng> polygonPointList = new List<PointLatLng>(pointCount);//用于存放多边形顶点\n\n        double interval = 2 * Math.PI / pointCount;\n        for (double degree = 0; degree < 2 * Math.PI; degree += interval)\n        {\n            double tempX = cartesianCenterX + R * Math.Cos(degree);\n            double tempY = cartesianCenterY + R * Math.Sin(degree);\n            double tempLng = double.MaxValue;\n            double tempLat = double.MaxValue;\n            mapControl.MapProvider.Projection.FromCartesianTGeodetic(tempX, tempY, cartesianCenterZ, out tempLat, out tempLng);//投影到WGS84坐标系\n            polygonPointList.Add(new PointLatLng(tempLat, tempLng));\n        }\n\n        GMapPolygon circle = new GMapPolygon(polygonPointList);\n        {\n            circle.ZIndex = (int)LayerIndex.Polygon;\n        }\n        mapControl.Markers.Add(circle);//添加到地图\n    }\n    ```\n    效果如下：\n    ![软件截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/GMap-Wpf-Draw-Circle.png)<br>\n    因为投影问题，说好的圆变为了椭圆，如果想生成正圆，可以在程序中使用一些WebAPI服务替换GMap的投影服务，我们项目使用的是搭建在自己服务器上的的GeoServer服务。效果如下：\n    ![软件截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/FGIS-Damage-Circle.png)<br>\n    `备注：`两张图片截图自不同的程序。\n <br>\n## 未指定长宽的要素与其他要素间相对定位的方式\n在使用GMap添加要素的时候，遇到需要对要素添加Tooltip，但不能指定Tooltip的长宽，且该要素与Tooltip需要水平中心对其，试过很多办法都不能成功，因为wpf控件的ActualWidth和ActualHeight属性必须加载过一次才能有正确的属性值，也就是说如果根据长宽计算GMapMarker的偏移量，Tolltip在第一次显示的时候无法正确定位，经过探索，最终利用wpf控件的SizeChanged响应函数实现了该效果，如果您有其他方法实现，希望能在评论中指出。效果如下：<br>\n![软件截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/GMap-Tooltip.png)<br>\n```C#\npublic void AddIconWithTooltip(PointLatLng pll, Uri iconUri, string tooltip)\n{\n    Guid id = Guid.NewGuid();\n    \n    //添加tooltip显示窗口\n    GMapMarker tooltipViewer = new GMapMarker(pll);\n    {\n        tooltipViewer.ZIndex = (int)LayerIndex.Point;\n        tooltipViewer.Tag = id;\n        TooltipForMap content = new TooltipForMap(tooltip, tooltipViewer);\n        tooltipViewer.Shape = content;\n        tooltipViewer.Shape.Visibility = Visibility.Hidden;\n    }\n    mapControl.Markers.Add(tooltipViewer);\n    \n    UIElement shape = new MyIcon(new BitmapImage(iconUri), tooltipViewer);//构造函数：MyIcon(ImageSource image, GMapMarker iconTooltipViewer, double width = 22, double height = 22, bool showTipAlways = false)\n    \n    GMapMarker iconMarker = new GMapMarker(pll);\n    {\n        iconMarker.ZIndex = (int)layerIndex;\n        iconMarker.Offset = new Point(-11, -11);\n        iconMarker.Tag = id;\n        iconMarker.Shape = shape;\n    }\n    mapControl.Markers.Add(iconMarker);\n}\n```\n`注意：`代码中id的作用是用于GMapMarker间的逻辑关联，方便同时从MapControl中移除。<br>\n关键代码：\n```C#\nTooltipForMap content = new TooltipForMap(tooltip, tooltipViewer);\n```\n其中TooltipForMap类的SizeChanged函数如下：\n```C#\nprivate void TooltipForMap_SizeChanged(object sender, SizeChangedEventArgs e)\n{\n    _TooltipViewer.Offset = new Point(-ActualWidth / 2, -ActualHeight - 22);\n}\n```\n`注意：`_TooltipViewer和传入构造函数的tooltipViewer为同一实例。\n*持续更新中...*","tags":["GMap.net"],"categories":["software"]},{"title":"Android学习心得","url":"/2017/08/19/Android学习心得/","content":"** 参加四维图新地图制图大赛，写了个Android App，现在把学到的知识记录一下 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n","tags":["AndroidStudio"],"categories":["language"]},{"title":"GIS-for-Web应用开发之道-学习心得","url":"/2017/08/19/GIS-for-Web应用开发之道-学习心得/","content":"** GIS-for-Web应用开发之道 读书心得 ** <Excerpt in index | 首页摘要>\n    在此感谢[康老师](http://urbancolab.org/ \"Chaogui Kang\")的指导\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["GIS"],"categories":["web"]},{"title":"git学习心得","url":"/2017/08/19/git学习心得/","content":"** git命令行学习小记 ** <Excerpt in index | 首页摘要>\n    利用git命令行托管代码到github。搭建自己的git服务\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["Github"],"categories":["software"]},{"title":"在VS中使用Github","url":"/2017/08/19/在VS中使用Github/","content":"** vs中使用GitHub的方法 ** <Excerpt in index | 首页摘要>\n    将VS工程代码提交到github或自己的git服务\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["VS"],"categories":["software"]},{"title":"团队项目中Github的使用","url":"/2017/08/19/团队项目中Github的使用/","content":"** 前几个月学习了Github的使用，希望我的经验能帮助到那些想要了解和学习Github的人 ** <Excerpt in index | 首页摘要>\n    本文将讲解团队项目中Github的基本使用，笔者的操作系统为Win10\n<!-- more -->\n<The rest of contents | 余下全文>\n## 前言\n[Github](https://github.com/)是一个面向开源及私有软件项目的托管平台，因为只支持git作为唯一的版本库格式进行托管，故名GitHub。\ngitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。[百度百科](https://baike.baidu.com/item/github/10145341)\n## 创建仓库并提交、推送文件到远程仓库\n- 在本地操作系统上安装[git](https://git-scm.com/)，这是[下载页面](https://git-scm.com/downloads)，对于git的安装和配置，在此不做介绍。\n- 登录[Github](https://github.com/)并点击\"New repository\"按钮，新建远程仓库。<br>\n![新建远程仓库](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/github_usage/new.png)\n- 进入新建仓库页面，填写仓库信息，点击\"Create repository\"按钮，完成远程仓库的创建。<br>\n![新建远程仓库](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/github_usage/create.png)\n- 出现以下界面说明创建成功。<br>\n![新建远程仓库](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/github_usage/created.png)<br>\n`注意：`如果在上一个页面没有选择创建.gitignore、LICENSE、README.md等文件，可以之后添加。当前只有master分支（git的默认分支为master），您也可以点击上图中的\"Branch:master\"下拉按钮，新建分支。<br>\n- 在本地新建文件夹，用于存放仓库，文件夹必须为空。在文件夹中按住Shift点击鼠标右键，点击\"在此处打开命令窗口\"，或直接点击鼠标右键点击\"Git Bash Here\"（如果没有该选项，则需找到git bash所在位置，启动bash，并导航进入本文件夹）。\n- 键入下面的命令初始化本地仓库。<br>\n```Bash\ngit init\n```\n- 为本地仓库添加远程仓库。<br>\n```Bash\ngit remote add origin https://github.com/CS-Tao/example.git\n```\n`注意：`该命令的格式为 \"git remote add 远程仓库的别名（方便记忆和键入） 远程仓库的url\"。<br>\n- 拉取远程仓库并合并到本地仓库。<br>\n```Bash\ngit pull origin master\n```\n`注意：`该命令的格式为 \"git pull 远程仓库的别名（或url） 希望拉取的分支\"。该命令会自动在本地仓库中创建master分支，另外，\"git pull\"命令相当于\"git fetch\"命令和\"git merge\"命令的集成，在此不再详述。<br>\n- 这三个命令的效果如下。<br>\n![建立本地仓库](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/github_usage/first_pull.png)<br>\n- 假如您现在在本项目文件夹中新建了\"NewFolder\"文件夹，并在文件夹中添加了source.cpp文件，您可以依次执行以下命令将新建的文件提交到远程仓库。<br>\n```Bash\ngit add NewFolder/source.cpp\ngit commit -m \"Add source.cpp\"\ngit push origin master\n```\n`注意：`\n    1. 无论是新建文件，还是对文件做了修改，都可以键入类似的命令提交并推送文件。\n    2. 向库中添加文件的命令格式为，\"git add 文件或文件夹\"，不同文件或文件夹用空格隔开，添加文件夹时会把文件夹内部的所有文件一并添加。\n    3. 在执行\"git commit -m \"这次提交做了什么\"\"时，git会自动检测文件是否为新建文件或是否做了修改，并将新建或修改的文件或文件夹提交到本地仓库。\n    4. \"git push 远程仓库的别名（或url） 希望推送到的分支\"命令会将本地的提交推送到远程仓库。<br>\n![推送到远程](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/github_usage/first_push.png)<br>\n- 到此为止，本地仓库和远程仓库的视图如下。<br>\n![本地仓库](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/github_usage/folder.png)<br>\n![远程仓库](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/github_usage/github_addFile.png)\n\n## 新建本地分支并推送到远程\n敬请期待\n## fork团队组长的仓库并合并不同成员的提交\n敬请期待\n## 合并冲突的方法\n敬请期待","tags":["Github"],"categories":["software"]},{"title":"C#中await和async","url":"/2017/08/19/C-中await和async/","content":"** C#中await和async使用介绍 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n","tags":["C#"],"categories":["language"]},{"title":"Wpf使用MahApp.Metro主题","url":"/2017/08/19/Wpf使用MahApp-Metro主题/","content":"** Wpf使用MahApp.Metro主题的步骤小记 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["Xaml"],"categories":["language"]},{"title":"2017年暑假旅游笔记","url":"/2017/08/17/暑假旅游笔记/","content":"** 暑假旅行笔记 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n## 起点：彭水\n持续更新...\n## 第一站：涪陵\n持续更新...\n## 第二站：重庆\n持续更新...\n## 第三站：成都\n持续更新...\n## 第四站：重庆\n持续更新...\n## 终点：彭水\n持续更新...\n","categories":["Life"]},{"title":"ISODATA算法学习心得及非监督分类软件得商业化界面实现","url":"/2017/08/17/ISODATA算法学习心得及非监督分类软件得商业化界面实现/","content":"** ISODATA和Winform ** <Excerpt in index | 首页摘要>\n    [姚剑老师](http://www.scholat.com/jianyao \"Jian Yao\")模式识别作业，代码已托管至[Github](https://github.com/CS-Tao/ImageFactory \"ImageFactory\")\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### ISODATA算法介绍\nISODATA(Iterative Selforganizing Data Analysis Techniques Algorithm)算法，即迭代自组织数据分析算法。该算法是在k-均值算法的基础上，增加对聚类结果的“合并”和“分裂”两个操作，并设定算法运行控制参数的一种聚类算法。迭代次数会影响最终结果，迭代参数选择很重要。待续...\n### 商业化界面的实现\n采用Winform实现。待续...","tags":["ISODATA"],"categories":["software"]}]