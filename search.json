[{"title":"Js利用百度地图API进行坐标转换","url":"/2017/09/04/Js利用百度API进行坐标转换/","content":"** 在Js中利用百度地图API对地理坐标系和投影坐标系（墨卡托）进行互转 **<Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n## 导入js文件\n在html文件中添加<br>\n```javascript\n<script src=\"http://api.map.baidu.com/api?v=1.2\"></script>\n```\n## 地理坐标转为平面坐标\n```javascript\nvar projection = new BMap.MercatorProjection();\nvar mercatorPoint = projection.lngLatToPoint(new BMap.Point(114.3908, 30.4879));\nalert(\"x = \" + mercatorPoint.x + \", y = \" + mercatorPoint.y);\n```\n## 平面坐标转为地理坐标\n```javascript\nvar projection = new BMap.MercatorProjection();\nvar lngLat = projection.pointToLngLat(new BMap.Pixel(12734064.16, 3544542.8));\nalert(\"lng = \" + lngLat.lng + \", lat = \" + lngLat.lat);\n```","tags":["百度API"],"categories":["language"]},{"title":"夜跑助手App-路径规划的实现","url":"/2017/09/03/夜跑助手App-路径规划的实现/","content":"** [夜跑助手App](https://github.com/CS-Tao/Route-NightRun)路径规划的实现 ** <Excerpt in index | 首页摘要>\n    夜跑助手App是我们小组参加四维图新地图制图大赛的成果之一，现在对其中的夜跑路径规划的方式进行记录\n<!-- more -->\n<The rest of contents | 余下全文>\n## 按站点进行路径规划\n### 原理和方法\n按站点进行路径规划的方式主要是利用[GraphHopper](https://www.graphhopper.com/)提供的WebAPI进行路径规划，通过对Rest接口发送Get请求获取json数据，如[示例](https://graphhopper.com/api/1/route?point=49.932707,11.588051&point=50.3404,11.64705&vehicle=car&debug=false&key=f8821850-c1f8-4f8f-befb-f976c887ebfb&optimize=true)。\n\n### 具体实现\n- 通过用户在手机屏幕上的双击操作获得用户希望经过的站点并进行标记\n- 在用户指定的站点链表的首位加上用户位置\n- 将上一步产生的站点列表投影为地理坐标\n- 生成http请求\n- 得到返回的json数据\n- 解析数据，此时便可得到路径信息\n- 将路径显示到屏幕上\n- 同时计算路径附近两百米形成的地理坐标框，发送http请求到我们自己的服务器\n- 得到饮品店信息并进行显示\n\n流程图如下：<br>\n![流程图](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E7%AB%99%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92.png)<br>\n效果图如下：<br>\n![App截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E7%AB%99%E7%82%B9%E8%A7%84%E5%88%92%E8%B7%AF%E5%BE%841.jpg)<br>\n![App截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E7%AB%99%E7%82%B9%E8%A7%84%E5%88%92%E8%B7%AF%E5%BE%842.jpg)<br>\n\n## 按路径长度进行路径规划\n### 原理和方法\n按路径长度进行路径规划相比于按站点的路径规划显得更加复杂，需要预定若干站点，并对符合预定要求的站点依次利用GraphHopper的Rest接口计算最短距离，接着得到与指定路径长度的一半最接近的距离和其对应的站点，最后通过GraphHopper得到最短路径。\n\n### 具体实现\n`注意：`夜跑区域的站点数据，由App维护人员通过其他软件采集并上传到数据库，软件已托管至[Github](https://github.com/CS-Tao/DataAcquisitionForNightRunning)。\n- 用户输入路径长度，设为a\n- 得到以用户为中心周围a/4到a/2区域内的所有站点\n- 依次利用GraphHopper的最短路径接口发送http请求，并获得用户位置到上一步所有站点的路径距离\n- 将这些距离值与与a/2比较，得到与a/2最接近的距离，并记录其对应的站点\n- 通过发送http请求获得用户位置到该站点的最短路径\n- 解析数据并显示路径\n- 显示附近的饮品店，和之前的方式一样，在此不详述\n\n流程图如下：<br>\n![流程图](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E8%BF%9B%E8%A1%8C%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92.png)<br>\n效果图如下：<br>\n![App截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E8%BF%9B%E8%A1%8C%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%921.png)<br>\n![App截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/%E6%8C%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E8%BF%9B%E8%A1%8C%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%922.png)<br>\n## 结束语\n按指定站点进行路径规划得到的是环形回路，按指定路径长度得到的是一条供往返的线路。笔者思考了很久，最终采用了如上文叙述的方法进行按路径长度规划路径，如果您有更好的方法，无论是算法还是工具，希望您能在评论中指出，共同进步，非常感谢。","tags":["WebAPI"],"categories":["software"]},{"title":"Ubuntu系统下的PostgreSQL安装和配置","url":"/2017/09/02/Ubuntu系统下的PostgreSQL安装和配置/","content":"** Ubuntu 16.04系统下的PostgreSQL 9.6安装和配置的详细步骤 ** \n<Excerpt in index | 首页摘要>\nPostgreSQL 是一个自由的对象-关系数据库服务器(数据库管理系统)，它在 BSD-风格许可证下发行\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## PostgreSQL介绍\n[PostgreSQL](https://www.postgresql.org/)是以加州大学伯克利分校计算机系开发的 POSTGRES，现在已经更名为PostgreSQL，版本 4.2为基础的对象关系型数据库管理系统（ORDBMS），开发语言为C/C++。PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。\n\n## PostgresSQL安装\n- 添加apt-repository\n    ```Bash\n    sudo add-apt-repository \"deb http://apt.postgresql.org/pub/repos/apt/ xenial-pgdg main\"\n    ```\n- 载入apt-repository的签名\n    ```Bash\n    wget --quiet -O -\n    https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -\n    ```\n- 更新package列表\n    ```Bash\n    sudo apt-get update\n    ```\n- 通过apt-get工具安装PostgreSQL\n    ```Bash\n    apt-get install postgresql-9.6\n    ```\n    \n## 配置PostgreSQL\n- 切换到postgres用户\n    ```Bash\n    sudo su postgres\n    ```\n- 登录到postgresql\n    ```Bash\n    psql postgres\n    ```\n    如果看到如下页面则说明之前的努力没有白费，已经安装成功了。<br>\n    ![Putty截图](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/PostgreSQL%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png)\n- 更改用户密码\n    在当前界面下输入\n    ```Bash\n    \\password\n    ```\n    输入你想设置的PostgreSQL密码。输入\\q回车退出。\n- 设置连接权限\n    - 打开配置文件\n        ```Bash\n        vim /etc/postgresql/9.1/main/postgresql.conf\n        ```\n    - 修改连接权限为所有主机\n        ```Bash\n        #listen_addresses = ‘localhost’改为 listen_addresses = ‘*’\n        ```\n        `注意：`需要去掉#号\n    - 启用密码验证\n        ```Bash\n        #password_encryption = on 改为 password_encryption = on\n        ```\n        `注意：`需要去掉#号\n- 设置用户ip段\n    - 打开配置文件\n        ```Bash\n        vim /etc/postgresql/9.1/main/pg_hba.conf\n        ```\n    - 在文件末尾添加如下内容\n        ```Bash\n        host all all 0.0.0.0/0 md5\n        ```\n        `注意：`0.0.0.0为地址段。0为掩码的二进制位，可取数值为0、8、16、24、32。md5为加密方式\n        `示例：`192.168.0.0/16代表192.168.0.1 ~ 192.168.255.254\n- 重启PostgreSQL服务\n    ```Bash\n    sudo service postgres restart\n    ```\n    \n## 登录数据库\n- 本地登录\n    ```Bash\n    psql -U postgres -h 127.0.0.1\n    ```\n- 远程登录\n    ```Bash\n    psql -U postgres -h 远程IP地址\n    ```","tags":["Ubuntu"],"categories":["software"]},{"title":"如何利用hexo发表文章","url":"/2017/08/24/如何利用hexo发表文章/","content":"** 如何利用hexo发表文章 ** <Excerpt in index | 首页摘要>\n    本文修改自[Hexo](https://hexo.io/)自动创建的Hello-World.md，Hexo代码开源。详见[GitHub](https://github.com/hexojs/hexo/)\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 新建文章并发表\n\n## 新建文章\n\n``` bash\n$ hexo new \"新文章\"\n```\n\n## 写文章\n详见：Hexo[官方文档](https://hexo.io/docs/writing.html)\n\n## 生成静态文件\n\n``` bash\n$ hexo generate\n```\n\n详见：Hexo[官方文档](https://hexo.io/docs/generating.html)\n\n## 启动hexo服务\n\n``` bash\n$ hexo server\n```\n\n详见：Hexo[官方文档](https://hexo.io/docs/server.html)\n\n## 部署到远程\n\n``` bash\n$ hexo deploy\n```\n\nHexo[官方文档](https://hexo.io/docs/deployment.html)\n","tags":["Hexo"],"categories":["web"]},{"title":"GMap.net for WPF 使用心得","url":"/2017/08/19/GMap.net-for-WPF-使用心得/","content":"** GMap.net for WPF ** <Excerpt in index | 首页摘要>\n    利用GMap.net for WPF绘制点线面的方式以及未指定长宽的要素与其他要素间相对定位的方式\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## GMap.net概述\n[GMap.net](https://greatmaps.codeplex.com/ \"进入GMap.NET的项目地址\")是一个强大、免费、跨平台、开源的.NET控件，它在WinForm和WPF环境中能够通过Google, Yahoo!, Bing, OpenStreetMap, ArcGIS, Pergo, SigPac等实现寻找路径、地理编码以及地图展示功能，并支持缓存和运行在Mobile环境中。<br>GMap.NET是一个开源的GEO地图定位和跟踪程序。就像谷歌地图、雅虎地图一样，可以自动计算两地的距离，定位经纬度，与Google地图不同的是，该项目是建立在WinForm框架或WPF框架基础上的。可以对地图放大缩小，进行城市标记等。\n  <br>\n## GMap.net for WPF 绘制要素\n因为现在正在利用GMap.net for WPF写一个项目，所以我对WPF版本更加熟悉，如有错误或不当之处，还望指出，共同进步！\n\n* 不同于Winform版本，WPF版本没有图层的概念，但用于显示要素的对象GMapMarker提供了Zindex属性，该属性值大的会遮盖属性值小的。所以大家可以利用Zindex对地理要素建立逻辑上的图层关联。\n \n* WinForm版本绘图可以直接在显示对象上设置图形的属性，如：\n    ```C#\n    GMapPolygon polygon = new GMapPolygon(pointList, \"Polygon\");\n    {\n        polygon.IsHitTestVisible = true;\n        polygon.Fill = new SolidBrush(Color.FromArgb(50, Color.Red));\n        polygon.Stroke = new Pen(Color.Blue, 2);\n    }\n    overlay.Polygons.Add(polygon);\n    ```\n    对于wpf版本的点对象，可以直接指定显示用户控件，如：<br>\n    ```C#\n    GMapMarker marker = new GMapMarker(pointLatLng);\n    {\n        MyUserControl myUserControl = new MyUserControl()\n        marker.Shape = myUserControl;\n        marker.ZIndex = (int)LayerIndex.Point;\n        marker.Offset = new Point(-myUserControl.ActualWidth / 2, -myUserControl.ActualHeight / 2);\n    }\n    mapControl.Markers.Add(marker);\n    ```\n    其中MyUserControl可以重载自UserControl，并自定义显示内容。LayerIndex为自定义的枚举类型。mapControl重载自GMapControl。\n    但是wpf版本的线的属性设置需要重载GMapControl的CreateRoutePath方法，面的属性设置需要重载CreatePolygonPath方法。为了不影响原函数的内容，我们可以参考GMapControl的源代码[*GMapControl.cs*](https://greatmaps.codeplex.com/SourceControl/latest#GMap.NET.WindowsPresentation/GMap.NET.WindowsPresentation/GMapControl.cs \"查看源码文件\")文件。重载CreateRoutePath方法和CreatePolygonPath后的内容如下，只做了少量修改：\n    ```C#\n    /// <summary>\n    /// creates path from list of points, for performance set addBlurEffect to false\n    /// </summary>\n    /// <param name=\"pl\"></param>\n    /// <returns></returns>\n    public override Path CreateRoutePath(List<Point> localPath, bool addBlurEffect)\n    {\n        // Create a StreamGeometry to use to specify myPath.\n        StreamGeometry geometry = new StreamGeometry();\n        \n        using (StreamGeometryContext ctx = geometry.Open())\n        {\n            ctx.BeginFigure(localPath[0], false, false);\n            \n            // Draw a line to the next specified point.\n            ctx.PolyLineTo(localPath, true, true);\n        }\n        \n        // Freeze the geometry (make it unmodifiable)\n        // for additional performance benefits.\n        geometry.Freeze();\n        \n        // Create a path to draw a geometry with.\n        Path myPath = new Path();\n        {\n            // Specify the shape of the Path using the StreamGeometry.\n            myPath.Data = geometry;\n            \n            if (addBlurEffect)\n            {\n                BlurEffect ef = new BlurEffect();\n                {\n                    ef.KernelType = KernelType.Gaussian;\n                    ef.Radius = 0.0;\n                    ef.RenderingBias = RenderingBias.Performance;\n                }\n                \n                myPath.Effect = ef;\n            }\n\n            myPath.Stroke = lineBrush;\n            myPath.StrokeThickness = lineWidth;\n            myPath.StrokeLineJoin = PenLineJoin.Round;\n            myPath.StrokeStartLineCap = PenLineCap.Triangle;\n            myPath.StrokeEndLineCap = PenLineCap.Round;\n            \n            myPath.Opacity = lineOpacity;\n            myPath.IsHitTestVisible = false;\n        }\n        return myPath;\n    }\n    ```\n    `注意:`代码中lineBrush、lineWidth、lineOpacity为重载GMapControl时新添的公共字段。\n     \n     ```C#\n    /// <summary>\n    /// creates path from list of points, for performance set addBlurEffect to false\n    /// </summary>\n    /// <param name=\"pl\"></param>\n    /// <returns></returns>\n    public override Path CreatePolygonPath(List<Point> localPath, bool addBlurEffect)\n    {\n        // Create a StreamGeometry to use to specify myPath.\n        StreamGeometry geometry = new StreamGeometry();\n\n        using (StreamGeometryContext ctx = geometry.Open())\n        {\n            ctx.BeginFigure(localPath[0], true, true);\n\n            // Draw a line to the next specified point.\n            ctx.PolyLineTo(localPath, true, true);\n        }\n\n        // Freeze the geometry (make it unmodifiable)\n        // for additional performance benefits.\n        geometry.Freeze();\n\n        // Create a path to draw a geometry with.\n        Path myPath = new Path();\n        {\n            // Specify the shape of the Path using the StreamGeometry.\n            myPath.Data = geometry;\n\n            if (addBlurEffect)\n            {\n                BlurEffect ef = new BlurEffect();\n                {\n                    ef.KernelType = KernelType.Gaussian;\n                    ef.Radius = 0.0;\n                    ef.RenderingBias = RenderingBias.Performance;\n                }\n\n                myPath.Effect = ef;\n            }\n\n            myPath.Stroke = polygonStrokeBrush;\n            myPath.StrokeThickness = polygonThickness;\n            myPath.StrokeLineJoin = PenLineJoin.Miter;\n            myPath.StrokeStartLineCap = PenLineCap.Triangle;\n            myPath.StrokeEndLineCap = PenLineCap.Square;\n\n            myPath.Fill = polygonFillBush;\n\n            myPath.Opacity = polygonOpacity;\n            myPath.IsHitTestVisible = false;\n        }\n        return myPath;\n    }\n    ```\n    `注意:`代码中polygonStrokeBrush、polygonThickness、polygonFillBush、polygonOpacity为重载GMapControl时新添的公共字段。\n* wpf版本只能绘制Point、PolyLine、Polygon三种图形，绘制圆则需要借助多边形的绘制。示例如下：\n    ```C#\n    public void DrawCircle(PointLatLng center, double R)\n    {\n        double cartesianCenterX = double.MaxValue;\n        double cartesianCenterY = double.MaxValue;\n        double cartesianCenterZ = double.MaxValue;\n\n        mapControl.MapProvider.Projection.FromGeodeticToCartesian(center.Lat, center.Lng, 0, out cartesianCenterX, out cartesianCenterY, out cartesianCenterZ);//将圆心投影到笛卡尔坐标系\n\n        int pointCount = 200;//用于拟合圆的多边形顶点个数\n\n        List<PointLatLng> polygonPointList = new List<PointLatLng>(pointCount);//用于存放多边形顶点\n\n        double interval = 2 * Math.PI / pointCount;\n        for (double degree = 0; degree < 2 * Math.PI; degree += interval)\n        {\n            double tempX = cartesianCenterX + R * Math.Cos(degree);\n            double tempY = cartesianCenterY + R * Math.Sin(degree);\n            double tempLng = double.MaxValue;\n            double tempLat = double.MaxValue;\n            mapControl.MapProvider.Projection.FromCartesianTGeodetic(tempX, tempY, cartesianCenterZ, out tempLat, out tempLng);//投影到WGS84坐标系\n            polygonPointList.Add(new PointLatLng(tempLat, tempLng));\n        }\n\n        GMapPolygon circle = new GMapPolygon(polygonPointList);\n        {\n            circle.ZIndex = (int)LayerIndex.Polygon;\n        }\n        mapControl.Markers.Add(circle);//添加到地图\n    }\n    ```\n    效果如下：\n    ![软件截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/GMap-Wpf-Draw-Circle.png)<br>\n    因为投影问题，说好的圆变为了椭圆，如果想生成正圆，可以在程序中使用一些WebAPI服务替换GMap的投影服务，我们项目使用的是搭建在自己服务器上的的GeoServer服务。效果如下：\n    ![软件截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/FGIS-Damage-Circle.png)<br>\n    `备注：`两张图片截图自不同的程序。\n <br>\n## 未指定长宽的要素与其他要素间相对定位的方式\n在使用GMap添加要素的时候，遇到需要对要素添加Tooltip，但不能指定Tooltip的长宽，且该要素与Tooltip需要水平中心对其，试过很多办法都不能成功，因为wpf控件的ActualWidth和ActualHeight属性必须加载过一次才能有正确的属性值，也就是说如果根据长宽计算GMapMarker的偏移量，Tolltip在第一次显示的时候无法正确定位，经过探索，最终利用wpf控件的SizeChanged响应函数实现了该效果，如果您有其他方法实现，希望能在评论中指出。效果如下：<br>\n![软件截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/GMap-Tooltip.png)<br>\n```C#\npublic void AddIconWithTooltip(PointLatLng pll, Uri iconUri, string tooltip)\n{\n    Guid id = Guid.NewGuid();\n    \n    //添加tooltip显示窗口\n    GMapMarker tooltipViewer = new GMapMarker(pll);\n    {\n        tooltipViewer.ZIndex = (int)LayerIndex.Point;\n        tooltipViewer.Tag = id;\n        TooltipForMap content = new TooltipForMap(tooltip, tooltipViewer);\n        tooltipViewer.Shape = content;\n        tooltipViewer.Shape.Visibility = Visibility.Hidden;\n    }\n    mapControl.Markers.Add(tooltipViewer);\n    \n    UIElement shape = new MyIcon(new BitmapImage(iconUri), tooltipViewer);//构造函数：MyIcon(ImageSource image, GMapMarker iconTooltipViewer, double width = 22, double height = 22, bool showTipAlways = false)\n    \n    GMapMarker iconMarker = new GMapMarker(pll);\n    {\n        iconMarker.ZIndex = (int)layerIndex;\n        iconMarker.Offset = new Point(-11, -11);\n        iconMarker.Tag = id;\n        iconMarker.Shape = shape;\n    }\n    mapControl.Markers.Add(iconMarker);\n}\n```\n`注意：`代码中id的作用是用于GMapMarker间的逻辑关联，方便同时从MapControl中移除。<br>\n关键代码：\n```C#\nTooltipForMap content = new TooltipForMap(tooltip, tooltipViewer);\n```\n其中TooltipForMap类的SizeChanged函数如下：\n```C#\nprivate void TooltipForMap_SizeChanged(object sender, SizeChangedEventArgs e)\n{\n    _TooltipViewer.Offset = new Point(-ActualWidth / 2, -ActualHeight - 22);\n}\n```\n`注意：`_TooltipViewer和传入构造函数的tooltipViewer为同一实例。\n*持续更新中...*","tags":["GMap.net"],"categories":["software"]},{"title":"Android学习心得","url":"/2017/08/19/Android学习心得/","content":"** 参加四维图新地图制图大赛，写了个Android App，现在把学到的知识记录一下 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n","tags":["AndroidStudio"],"categories":["language"]},{"title":"GIS-for-Web应用开发之道-学习心得","url":"/2017/08/19/GIS-for-Web应用开发之道-学习心得/","content":"** GIS-for-Web应用开发之道 读书心得 ** <Excerpt in index | 首页摘要>\n    在此感谢[康老师](http://urbancolab.org/ \"Chaogui Kang\")的指导\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["GIS"],"categories":["web"]},{"title":"git学习心得","url":"/2017/08/19/git学习心得/","content":"** git命令行学习小记 ** <Excerpt in index | 首页摘要>\n    利用git命令行托管代码到github。搭建自己的git服务\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["Git"],"categories":["software"]},{"title":"在VS中使用Github","url":"/2017/08/19/在VS中使用Github/","content":"** vs中使用GitHub的方法 ** <Excerpt in index | 首页摘要>\n    将VS工程代码提交到github或自己的git服务\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["VS"],"categories":["software"]},{"title":"Github使用指南","url":"/2017/08/19/Github使用指南/","content":"** 前几个月学习了Github的使用，希望我的经验能帮助到那些想要了解和学习Github的人 ** <Excerpt in index | 首页摘要>\n    感谢在我迷惑的时候有[师兄](https://hpdell.github.io/ \"HPDell的个人博客\")的指点\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["Git"],"categories":["software"]},{"title":"C#中await和async","url":"/2017/08/19/C-中await和async/","content":"** C#中await和async使用介绍 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n","tags":["C#"],"categories":["language"]},{"title":"Wpf使用MahApp.Metro主题","url":"/2017/08/19/Wpf使用MahApp-Metro主题/","content":"** Wpf使用MahApp.Metro主题的步骤小记 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>","tags":["Xaml"],"categories":["language"]},{"title":"2017年暑假旅游笔记","url":"/2017/08/17/暑假旅游笔记/","content":"** 暑假旅行笔记 ** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n## 起点：彭水\n持续更新...\n## 第一站：涪陵\n持续更新...\n## 第二站：重庆\n持续更新...\n## 第三站：成都\n持续更新...\n## 第四站：重庆\n持续更新...\n## 终点：彭水\n持续更新...\n","categories":["Life"]},{"title":"ISODATA算法学习心得及非监督分类软件得商业化界面实现","url":"/2017/08/17/ISODATA算法学习心得及非监督分类软件得商业化界面实现/","content":"** ISODATA和Winform ** <Excerpt in index | 首页摘要>\n    [姚剑老师](http://www.scholat.com/jianyao \"Jian Yao\")模式识别作业，代码已托管至[Github](https://github.com/CS-Tao/ImageFactory \"ImageFactory\")\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### ISODATA算法介绍\nISODATA(Iterative Selforganizing Data Analysis Techniques Algorithm)算法，即迭代自组织数据分析算法。该算法是在k-均值算法的基础上，增加对聚类结果的“合并”和“分裂”两个操作，并设定算法运行控制参数的一种聚类算法。迭代次数会影响最终结果，迭代参数选择很重要。待续...\n### 商业化界面的实现\n采用Winform实现。待续...","tags":["ISODATA"],"categories":["software"]}]